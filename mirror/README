
                                  镜像数据包功能测试程序介绍
                                 _______________________________


Table of Contents
_________________

1 总结文档
.. 1.1 实现方式
.. 1.2 运行方式
.. 1.3 mempool
.. 1.4 发送镜像数据包过程
.. 1.5 网卡初始化过程
.. 1.6 互为转发端口的设置过程
.. 1.7 问题


1 总结文档
==========

1.1 实现方式
~~~~~~~~~~~~

  基于dpdk-1.8.0的l2fwd例子实现。一共有三块网卡。其中两块供l2fwd的原有流
  程做转发用。第三块网卡作镜像。

  rte_eth_tx_burst函数的发送机制大致如下：它需要一个指向mbuf的指针数组。
  把这些mbuf挂到网卡的发送队列上。同时释放之前已经发送完毕的mbuf。因此，
  在做镜像的时候，没有办法利用同一个mbuf既作原有的转发，又作镜像。因为
  rte_eth_tx_burst函数返回的时候数据包并没有实际发送出去。这时数据包只是
  在网卡队列上。如果这时候再次利用这个mbuf作镜像，会产生混乱。所以必须把
  原有的数据包copy到新的mbuf中，然后再转发。同时为了提高速度，需要一个
  mbuf的内存池。


1.2 运行方式
~~~~~~~~~~~~

  ./build/l2fwd -c 7 -n 2 -- -p 7向两块转发网卡之一上发包。然后在第三块
  镜像网卡上抓包验证。

  注意：因为发送过程是每32个包批量发送的。并且这里面没有实现超时。所以发
  送数据包的数量最好超过这个数目，否则抓不到。


1.3 mempool
~~~~~~~~~~~

  mempool的使用有两个步骤：通过rte_mempool_create创建内存池，第二通过
  rte_pktmbuf_alloc分配一个mbuf即可。


1.4 发送镜像数据包过程
~~~~~~~~~~~~~~~~~~~~~~

  因为是copy的数据包，所以原有的转发流程不变。只在转发流程中插入镜像功能，
  过程如下：从内存池中申请一个mbuf copy数据包到这个mbuf中修改镜像数据包
  的ip或者MAC把这个mbuf缓存到burst数组中如果数组满就调用发送函数。


1.5 网卡初始化过程
~~~~~~~~~~~~~~~~~~

  根据rte_eth_dev_count函数返回生效的网卡数量。从0开始按顺序对网卡设置对
  应的转发网卡初始化每个网卡的rx和tx队列启动网卡


1.6 互为转发端口的设置过程
~~~~~~~~~~~~~~~~~~~~~~~~~~

  l2fwd在main函数的初始化过程中，通过一个循环来设置互为转发的端口。存入
  l2fwd_dst_ports数组中。


1.7 问题
~~~~~~~~

  rte_eth_tx_burst 批量发送，有可能不成功。这种情况只能放弃重新发送。如
  果试图再次发送，可能会阻塞后续的镜像包。

  网卡队列问题如果业务处理线程多于镜像网卡队列。这时调用镜像功能会冲突可
  以让镜像模块作为一个独立的线程。所有需要镜像的包都发送到一个ring里。
  mirror线程从这个ring里取数据，然后发送。也可以让镜像队列和业务线程一一
  对应。在软件dpi中由框架提供解决办法。镜像模块不需要关心。

  rte_eth_tx_burst 的发送数组缓存需要一个定时器 镜像功能通过
  rte_eth_tx_burst() 发送，需要缓存数据包批量发送如果缓存之后，在没有数
  据包的话，需要定时器触发。
  [http://dpdk.org/doc/guides/prog_guide/timer_lib.html]
  [http://dpdk.org/doc/api/rte__timer_8h.html]软件dpi中，由主框架的发包
  函数内部处理超时

  如何指定用哪块网卡作镜像，哪块网卡作业务？编号是如何对应的？在测试程序
  中是手工直接写的编号。在软件dpi中，根据配置来作网卡名字和编号的对应。
